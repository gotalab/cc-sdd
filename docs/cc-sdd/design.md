# cc-sdd 設計（Design）

## 全体アーキテクチャ
- ランタイム: Node.js（ESM）
- 実行: `npx cc-sdd`
- 構成モジュール:
  1) CLI エントリ（引数解析、対話/非対話制御）
  2) 設定ローダ（`.cc-sdd.json` の読み書き）
  3) OS リゾルバ（`auto` → `mac|windows|linux` 決定）
  4) Kiro ルートリゾルバ（`--kiro-dir` / `kiroDir` の解決・検証）
  5) エージェントセレクタ（`--agent`。v1 は `claude-code` 固定）
  6) エージェントレイアウトリゾルバ（`AGENT_COMMANDS_DIR`/`AGENT_DIR`/`AGENT_DOC` の決定）
  7) テンプレ・レジストリ（マニフェスト/スニペット/テンプレ群の読み込み）
  8) アーティファクト検出（Detector）
  9) 計画生成（Planner: CREATE/UPDATE/SKIP/CONFLICT）
  10) 差分/表示（DryRun/Preview）
  11) バックアップ（Backup）
  12) 変更適用（Applier: テンプレ適用＋静的コピー）
  13) ロガー（色付け/表形式）
  14) コンテンツハッシュ管理（静的資産の追跡）

## コーディングスタイル（TypeScript）
- クラス（`class`）は使用しない。
- 代替: 関数 + ファクトリ関数 + プレーンオブジェクト。データ形状は `type`/`interface` を使用。
- 継承/デコレータは不使用。ESM モジュールに分割し、依存は関数引数で注入（DI）。

## 主要データモデル
```ts
// OS
export type OSType = 'mac' | 'windows' | 'linux';

// Agent（v1 は 'claude-code' 固定。将来: 'gemini-cli' | 'qwen-code'）
export type AgentType = 'claude-code' | 'gemini-cli' | 'qwen-code';

// Overwrite Policy
export type OverwritePolicy = 'prompt' | 'skip' | 'force';

// 設定（.cc-sdd.json）
export interface CCSddConfig {
  version: number;
  agent: AgentType;            // v1 既定: 'claude-code'
  os: 'auto' | OSType;
  resolvedOs?: OSType;
  lang: 'ja' | 'en' | 'zh-TW';
  kiroDir: string;             // default: '.kiro'（相対・ネスト可）
  overwrite: OverwritePolicy;
  backupDir?: string; // default: .cc-sdd.backup
  templateVersion?: string;
  lastAppliedAt?: string;
  fileHashes?: Record<string, string>; // v1: 平坦（出力パス→SHA-256）。将来は agents[...] に移行予定
  // 予約（将来の複数エージェント共存用）
  agents?: Partial<Record<AgentType, { fileHashes?: Record<string, string>; templateVersion?: string; lastAppliedAt?: string }>>;
  // 予約（将来のレイアウト上書き）
  agentLayouts?: Partial<Record<AgentType, { commandsDir?: string; agentDir?: string; docFile?: string }>>;
}

// アーティファクト（manifest）
export interface Artifact {
  id: string;
  outputPath?: string;         // 単一出力（static/template）時に使用
  source:
    | { type: 'template'; path: string; placeholders?: string[] }
    | { type: 'templateByLang'; baseDir: string; pattern: string }
    | { type: 'static'; path: string } // 単一静的ファイル
    | { type: 'staticDir'; from: string; toDir: string; include?: string[]; exclude?: string[] }; // ディレクトリコピー
  osSnippet?: boolean;        // OS 置換の有無（template のみ）
  when?: { agent?: AgentType | AgentType[] }; // 将来: エージェントで適用条件を切替
  detectors: Detector[];      // 存在/内容の検出
  apply: { whenMissing: 'create' | 'skip'; whenPresent: 'update' | 'skip' };
}

export type Detector =
  | { type: 'pathExists'; path: string }
  | { type: 'contentIncludes'; path: string; needle: string };

// 計画（Plan）
export type Operation = 'create' | 'update' | 'skip' | 'conflict';
export interface PlanItem { artifactId: string; path: string; op: Operation; reason?: string }
export interface Plan { items: PlanItem[] }
```

### 例: `agentLayouts`（任意のレイアウト上書き）
```json
{
  "agentLayouts": {
    "claude-code": {
      "commandsDir": ".claude/commands/kiro",
      "agentDir": ".claude",
      "docFile": "CLAUDE.md"
    }
  }
}
```

## テンプレート／静的アセット処理
- テンプレ形式: `.tpl.md` / `.tpl.json`
- 置換: __シンプルなプレースホルダ置換__（`{{NAME}}`）。`mustache` も可。
- 変数:
  - `LANG_CODE`（ja|en|zh-TW）
  - `KIRO_DIR`（Kiro ルートの相対パス。既定: `.kiro`。ネスト可）
  - `AGENT_DIR`（エージェント固有のルートディレクトリ。例: `.claude`）
  - `AGENT_DOC`（エージェント固有のドキュメントファイル名。例: `CLAUDE.md`）
  - `AGENT_COMMANDS_DIR`（エージェント固有のコマンド出力ルート。v1 既定: `.claude/commands/kiro`）
  - `CMD_*`（OS スニペットで供給: 例 `CMD_LIST_SPEC_DIR`, `CMD_FIND_ACTIVE_SPECS`）
- テンプレ適用手順:
  1) ベーステンプレ読み込み
  2) OS スニペット（`templates/snippets/os/{mac|windows|linux}.json`）を適用
  3) 言語変数を適用
  4) 出力ファイルヘッダに識別コメントを付与（例: `<!-- Generated by cc-sdd vX.Y.Z -->`）
- 静的コピー手順（非テンプレ資産: 例 `.md`, 画像/バイナリ）:
  1) テンプレ側ファイルの内容を読み取り、SHA-256 を計算
  2) 既存出力があれば同様にハッシュ比較
  3) `.cc-sdd.json:fileHashes[path]` と照合し、所有状態を判断
  4) Planner に `create/update/skip/conflict` を返す

## OS リゾルブ（auto）
```ts
function resolveOs(input: 'auto' | OSType): OSType {
  if (input !== 'auto') return input;
  const p = process.platform; // 'darwin' | 'win32' | 'linux' | ...
  if (p === 'darwin') return 'mac';
  if (p === 'win32') return 'windows';
  if (p === 'linux') return 'linux';
  // fallback（未知環境）
  return 'linux';
}
```
- WSL 検知は補助（`WSL_DISTRO_NAME` または `/proc/version` に `Microsoft`）。最終的には `linux`。

## Kiro ルート（kiroDir）の解決と検証
- 優先順位: CLI フラグ（`--kiro-dir`） > `.cc-sdd.json` の `kiroDir` > 既定（`.kiro`）
- 仕様:
  - リポジトリ相対パスのみ許可（絶対パス・`..` は不可）
  - ネスト可（例: `kiro`, `.work/kiro`, `docs/kiro`）
  - 使用可能文字: 英数・`._-/`
  - 存在しない場合は作成（空で可）
- テンプレ置換: 変数 `{{KIRO_DIR}}` をテンプレ/スニペットへ注入
- v1: 既存 `.kiro` からの自動移行は非対応（必要に応じて手動移行）

## エージェントレイアウトの解決（Agent Layout Resolver）
- 目的: エージェントごとの出力構成差（コマンド/ドキュメント/ルート）を抽象化してテンプレに渡す。
- 出力変数: `AGENT_COMMANDS_DIR` / `AGENT_DIR` / `AGENT_DOC` を解決してテンプレへ注入。
- 既定マッピング（現時点・仮含む）:
  - `claude-code`: `AGENT_COMMANDS_DIR = .claude/commands/kiro`, `AGENT_DIR = .claude`, `AGENT_DOC = CLAUDE.md`
  - `gemini-cli`（仮）: `AGENT_COMMANDS_DIR = .gemini/commands`, `AGENT_DIR = .gemini`, `AGENT_DOC = GEMINI.md`
  - `qwen-code`（仮）: `AGENT_COMMANDS_DIR = .qwen/commands`, `AGENT_DIR = .qwen`, `AGENT_DOC = QWEN.md`
- 将来の上書き手段:
  - `.cc-sdd.json: agentLayouts[agent]` により個別に上書き可能（指定があれば既定より優先）。
  - マニフェストでは `when.agent` で分岐し、必要に応じて出力パスを個別指定してもよい。

## アーティファクト検出（Detector）
- `manifest.json` に列挙した各アーティファクトに対して検出器（`pathExists`, `contentIncludes`）を評価。
- `contentIncludes` は識別コメント（`Generated by cc-sdd`）でバージョンや所有権を判断可能。
- 結果を `Planner` に渡して `create/update/skip/conflict` を割当。

### 静的アセットの判定アルゴリズム（擬似コード）
```ts
function classifyStatic(path, srcHash, existingHash, recordedHash, policy): Operation {
  if (!exists(path)) return 'create';
  if (recordedHash) {
    if (existingHash === recordedHash) {
      return existingHash === srcHash ? 'skip' : 'update'; // 我々が最後に書いた → 上書き可
    }
    // ユーザーが変更した可能性
    return policy === 'force' ? 'update' : (policy === 'skip' ? 'skip' : 'conflict');
  } else {
    // 記録なし（未管理の可能性）
    if (existingHash === srcHash) return 'skip';
    return policy === 'force' ? 'update' : (policy === 'skip' ? 'skip' : 'conflict');
  }
}
```

## 計画生成（Planner）
- 原則:
  - 既存なし → `create`
  - 既存あり + 自動生成印（cc-sdd）あり → `update`
  - 既存あり + 自動生成印なし → `conflict`（ユーザー資産の可能性）
- `--overwrite` との関係:
  - `prompt`: `conflict` を都度確認
  - `skip`: `conflict` は自動で `skip`
  - `force`: `conflict` も `update` と同様に上書き

静的資産については、上記に加えて `fileHashes` に基づく所有判定を適用。

## ドライラン / 差分表示
- `Plan` を表形式で表示。`create/update/skip/conflict` の件数集計。
- コンテンツ差分は最大 N 行のパッチ要約を表示（必要に応じて `diff` ライブラリ）。

## バックアップ（Backup）
- 変更対象の既存ファイルを `.cc-sdd.backup/YYYYMMDD-HHmmss/` 配下へ保存。
- `--backup=<dir>` 指定時はそのディレクトリ配下に保存。

## 変更適用（Applier）
- ファイル単位に `Plan` を実行:
  - `create`: 新規作成（親ディレクトリがなければ作成）
  - `update`: 上書き（事前にバックアップ）
  - `skip`: 変更なし
  - `conflict`: `prompt` なら質問、`skip/force` は自動処理
- ファイルヘッダへの識別コメントを維持/更新。
 - 静的資産更新時は `.cc-sdd.json:fileHashes[path]` を新しいハッシュに更新。

## 設定ファイル（.cc-sdd.json）
- 起動時に読み込み、欠損はフラグ/デフォルトで補完。
- 実行後に `agent`, `resolvedOs`, `lastAppliedAt`, `templateVersion`, `fileHashes` を更新。

### 例: `fileHashes`（claude-code の出力例）
```json
{
  "fileHashes": {
    ".claude/commands/kiro/README.md": "e3b0c44298fc1c149afbf4c8996fb924...",
    ".claude/commands/kiro/assets/logo.png": "2c26b46b68ffc68ff99b453c1d304134..."
  }
}
```

## テンプレ/スニペットの例
```json
// snippets/os/mac.json
{
  "CMD_LIST_SPEC_DIR": "!ls -la {{KIRO_DIR}}/specs/$ARGUMENTS/",
  "CMD_FIND_ACTIVE_SPECS": "!find {{KIRO_DIR}}/specs/ -name \"spec.json\" -exec grep -l \"implementation_ready.*true\" {} \\;"
}
```
```json
// snippets/os/windows.json
{
  "CMD_LIST_SPEC_DIR": "!powershell -NoProfile -Command \"Get-ChildItem -Force {{KIRO_DIR}}/specs/$ARGUMENTS | Format-Table -AutoSize\"",
  "CMD_FIND_ACTIVE_SPECS": "!powershell -NoProfile -Command \"Get-ChildItem -Recurse {{KIRO_DIR}}/specs -Filter spec.json | Where-Object { Select-String -Path $_.FullName -Pattern 'implementation_ready.*true' -Quiet } | Select-Object -ExpandProperty FullName\""
}
```

## エラーハンドリング
- 書込権限/存在しない親ディレクトリは自動作成、不可なら明示エラー。
- 解析不能なテンプレ/スニペットキーは警告してスキップ、処理は継続。
- 予期せぬ例外時は変更前のバックアップ案内を表示。

## 拡張性（将来）
- 新アーティファクトの追加: `manifest.json` に追記→自動判定・適用に組み込まれる。
- 複数エージェント対応: `--agent <claude-code|gemini-cli|qwen-code>`、`when.agent` で適用を分岐。テンプレ配置は `templates/agents/<agent>/**` を採用し、共通 OS スニペットは `templates/snippets/os/**` を再利用。
- エージェントレイアウトの上書き: `.cc-sdd.json: agentLayouts` により `AGENT_COMMANDS_DIR`/`AGENT_DIR`/`AGENT_DOC` の解決を変更可能。
- 新言語: `templates/agents/claude-code/docs/CLAUDE` に追加。`LANG_CODE` を拡張。
 - 静的資産の追加: `static`/`staticDir` を manifest に追記するだけで対応（`include/exclude` で柔軟な制御）。

## ロギング / 表示
- `create`: 緑, `update`: 青, `skip`: グレー, `conflict`: 黄
- 実行要約（件数/所要時間）、バックアップ先パス、`.cc-sdd.json` 更新情報。

## 環境・依存候補
- `fs-extra`（入出力/ディレクトリ作成）
- `globby`（テンプレ探索）
- `prompts` or `inquirer`（対話）
- `chalk`（色付け）
- `diff`（差分要約、任意）
- `mustache` or 独自シンプル置換

## サンプル実行フロー
```text
start → loadConfig → parseArgs → resolveOs → loadManifest → detectArtifacts → buildPlan →
( dry-run? showPlan : ( maybeBackup → applyPlan ) ) → saveConfig(fileHashes) → summary
```

## マニフェスト例（静的ディレクトリコピー）
```json
{
  "version": 1,
  "artifacts": [
    {
      "id": "commands_static_all",
      "source": {
        "type": "staticDir",
        "from": "templates/agents/claude-code/commands/kiro", // テンプレ配置は任意（例）
        "toDir": "{{AGENT_COMMANDS_DIR}}",
        "include": ["**/*"],
        "exclude": ["**/*.tpl.*"]
      },
      "detectors": [{ "type": "pathExists", "path": "{{AGENT_COMMANDS_DIR}}" }],
      "apply": { "whenMissing": "create", "whenPresent": "update" }
    }
  ]
}
```
