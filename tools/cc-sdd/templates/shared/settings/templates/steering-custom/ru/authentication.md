# Стандарты аутентификации и авторизации

[Назначение: унифицировать модель auth, жизненный цикл токенов/сессий, проверки разрешений и безопасность]

## Философия
- Чёткое разделение: аутентификация (кто) vs авторизация (что)
- Безопасность по умолчанию: минимальные привилегии, fail closed, короткоживущие токены
- UX-осведомлённость: трение где риск высок, гладкость в остальном

## Аутентификация

### Метод (выбор + обоснование)
- Варианты: JWT, Session, OAuth2, гибрид
- Выбор: [наш метод] потому что [причина]

### Поток (высокоуровневый)
```
1) Пользователь доказывает идентичность (учётные данные или провайдер)
2) Сервер верифицирует и выдаёт токен/сессию
3) Клиент отправляет токен с каждым запросом
4) Сервер проверяет токен и продолжает
```

### Жизненный цикл токена/сессии
- Хранение: httpOnly cookie или заголовок Authorization
- Истечение: короткоживущий access, более длинный refresh (если используется)
- Обновление: ротация токенов; учёт отзыва
- Отзыв: blacklist/ротация при logout/компрометации

### Паттерн безопасности
- Обязательный TLS; никогда не экспонировать токены в JS когда избежимо
- Привязка токена к audience/issuer; минимальные claims
- Рассмотреть привязку к устройству и IP/risk проверки для чувствительных действий

## Авторизация

### Модель разрешений
- Выбрать одну: RBAC / ABAC / ownership-based / гибрид
- Определить роли/атрибуты централизованно; избегать хардкода по кодовой базе

### Проверки (где применять)
- Route/middleware: грубая фильтрация
- Domain/service: fine-grained решения
- UI: условный рендеринг (без опоры на безопасность)

Пример паттерна:
```typescript
requirePermission('resource:action'); // route
if (!user.can('resource:action')) throw ForbiddenError(); // domain
```

### Владение
- Паттерн: владелец ИЛИ привилегированная роль может действовать
- Проверять на границе сущности перед мутацией

## Пароли и MFA
- Пароли: строгая политика, хэширование (bcrypt/argon2), никогда plaintext
- Сброс: time-limited токен, одноразовый, уведомление пользователя
- MFA: step-up для рискованных операций (policy-driven)

## API-to-API Auth
- Использовать API ключи или OAuth client credentials
- Минимальный scope ключей; ротация и аудит использования
- Rate limit по идентичности (user/key)

---
_Фокус на паттернах и решениях. Без library-specific кода._
