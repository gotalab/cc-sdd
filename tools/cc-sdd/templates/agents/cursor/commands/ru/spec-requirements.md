---
description: Сгенерировать требования для спецификации
allowed-tools: Bash, Glob, Grep, LS, Read, Write, Edit, MultiEdit, Update, WebSearch, WebFetch
argument-hint: <имя-функции>
---

# Генерация требований

<background_information>
- **Миссия**: Сгенерировать полные, тестируемые требования в формате EARS на основе описания проекта из инициализации спецификации
- **Критерии успеха**:
  - Создать полный документ требований, согласованный с контекстом steering
  - Следовать паттернам и ограничениям EARS проекта для всех критериев приёмки
  - Сфокусироваться на основной функциональности без деталей реализации
  - Обновить метаданные для отслеживания статуса генерации
</background_information>

<instructions>
## Основная задача
Сгенерировать полные требования для функции **$1** на основе описания проекта в requirements.md.

## Шаги выполнения

1. **Загрузить контекст**:
   - Прочитать `{{KIRO_DIR}}/specs/$1/spec.json` для языка и метаданных
   - Прочитать `{{KIRO_DIR}}/specs/$1/requirements.md` для описания проекта
   - **Загрузить ВЕСЬ контекст steering**: Прочитать весь каталог `{{KIRO_DIR}}/steering/` включая:
     - Стандартные файлы: `structure.md`, `tech.md`, `product.md`
     - Все кастомные файлы steering (независимо от настроек режима)
     - Это обеспечивает полную память и контекст проекта

2. **Прочитать руководства**:
   - Прочитать `{{KIRO_DIR}}/settings/rules/ears-format.md` для правил синтаксиса EARS
   - Прочитать `{{KIRO_DIR}}/settings/templates/specs/requirements.md` для структуры документа

3. **Сгенерировать требования**:
   - Создать начальные требования на основе описания проекта
   - Сгруппировать связанную функциональность в логические области требований
   - Применить формат EARS ко всем критериям приёмки
   - Использовать язык, указанный в spec.json

4. **Обновить метаданные**:
   - Установить `phase: "requirements-generated"`
   - Установить `approvals.requirements.generated: true`
   - Обновить метку времени `updated_at`

## Важные ограничения
- Фокус на ЧТО, а не КАК (без деталей реализации)
- Требования должны быть тестируемыми и проверяемыми
- Выбирать подходящий субъект для утверждений EARS (название системы/сервиса для ПО)
- Сначала сгенерировать начальную версию, затем итерировать с обратной связью пользователя (не задавать много вопросов заранее)
- Заголовки требований в requirements.md ДОЛЖНЫ включать только числовой ID в начале (например: "Требование 1", "1.", "2 Функция ..."); не использовать буквенные ID типа "Требование A"
</instructions>

## Руководство по инструментам
- **Сначала читать**: Загрузить весь контекст (спецификация, steering, правила, шаблоны) перед генерацией
- **Писать в конце**: Обновлять requirements.md только после полной генерации
- Использовать **WebSearch/WebFetch** только если нужны внешние доменные знания

## Описание вывода
Предоставить вывод на языке, указанном в spec.json:

1. **Сводка сгенерированных требований**: Краткий обзор основных областей требований (3-5 пунктов)
2. **Статус документа**: Подтвердить обновление requirements.md и метаданных spec.json
3. **Следующие шаги**: Направить пользователя как продолжить (утвердить и продолжить, или изменить)

**Требования к формату**:
- Использовать заголовки Markdown для ясности
- Включать пути файлов в блоки кода
- Сводка должна быть краткой (менее 300 слов)

## Безопасность и Fallback

### Сценарии ошибок
- **Отсутствует описание проекта**: Если в requirements.md нет описания проекта, запросить у пользователя детали функции
- **Неоднозначные требования**: Предложить начальную версию и итерировать с пользователем, а не задавать много вопросов заранее
- **Отсутствует шаблон**: Если файлы шаблонов не существуют, использовать встроенную резервную структуру с предупреждением
- **Язык не определён**: По умолчанию английский (`en`), если spec.json не указывает язык
- **Неполные требования**: После генерации явно спросить пользователя, покрывают ли требования всю ожидаемую функциональность
- **Каталог Steering пустой**: Предупредить пользователя, что контекст проекта отсутствует и может повлиять на качество требований
- **Нечисловые заголовки требований**: Если существующие заголовки не содержат числовой ID в начале (например, используют "Требование A"), нормализовать их до числовых ID и сохранять это соответствие (никогда не смешивать числовые и буквенные метки)

### Следующая фаза: Генерация дизайна

**Если требования утверждены**:
- Просмотреть сгенерированные требования в `{{KIRO_DIR}}/specs/$1/requirements.md`
- **Опциональный Gap-анализ** (для существующих кодовых баз):
  - Запустить `/kiro:validate-gap $1` для анализа разрыва реализации с текущим кодом
  - Определяет существующие компоненты, точки интеграции и стратегию реализации
  - Рекомендуется для brownfield-проектов; пропустить для greenfield
- Затем `/kiro:spec-design $1 -y` для перехода к фазе дизайна

**Если нужны изменения**:
- Предоставить обратную связь и повторно запустить `/kiro:spec-requirements $1`

**Примечание**: Утверждение обязательно перед переходом к фазе дизайна.

think
